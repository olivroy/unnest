% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unnest.R
\name{s}
\alias{s}
\alias{spec}
\title{Unnest specs}
\usage{
s(
  selector = NULL,
  ...,
  as = NULL,
  children = NULL,
  groups = NULL,
  include = NULL,
  exclude = NULL,
  stack = NULL
)

spec(
  selector = NULL,
  ...,
  as = NULL,
  children = NULL,
  groups = NULL,
  include = NULL,
  exclude = NULL,
  stack = NULL
)
}
\arguments{
\item{selector}{A shorthand syntax of a selector. Will be substituted by a
canonical (nested) specification with elements `as`, `children`, `groups`,
`include` etc. according to the following rules: TODO}

\item{as}{name for this field in the extracted data.frame}

\item{children, ...}{Unnamed list of children spec. `...` is merged into
`children`. `children` is part of canonical spec.}

\item{groups}{Named list of specs to be processed in parallel. The return
value is a named list of unnested data.frames. The results is the same as
when each spec is `unnest`ed separately except that `dedupe` parameter of
`unnest()` will work across groups and execution is faster because the
nested list is traversed once regardless of the number of groups.}

\item{include, exclude}{A list, a numeric vector or a character vector
specifying components to include. A list can combine numeric indexes and
character elements to extract.}

\item{stack}{Whether to stack this node (TRUE) or to spread it (FALSE). Note
atomic vectors are stacked according to `stack_atomic` parameter in
`unnest()` call. When `stack` is specified for an atomic node, it takes
precedence over `stack_atomic`.}
}
\description{
Unnest spec is a nested list with the same structure as the nested json and
specifies how the deeply nested components ought to be unnested. `s()` is a
shorthand synonym of `spec()`.
}
